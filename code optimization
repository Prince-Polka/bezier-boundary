/*

removed complex class using raw doubles instead, merged helper functions into the main function  
probably more can be done

simplified calculation of F 

simplified calculation of solutions

added alternatives for sine and atan2

unclear how accurate they are and wheter they be faster or slower

*/

final static double fastsin(double x) {
  /*
  will be way off for x not in range -Pi Pi
  */
  final double x2=x*x;
  return x 
  - (x*=x2)/6 
  + (x*=x2)/120 
  - (x*=x2)/5040 
  + (x*=x2)/362880 
  - (x*=x2)/39916800 
  + (x*=x2)/6227020800D
  - (x*=x2)/1307674368000D
  + (x*=x2)/355687428096000D;
}

double[] bezierTime( double A, double B, double C, double D, double E ) {
  double[] T = new double[3];
  double FAB, G, H, J, FG,x, y, n, r, multr;
  final double CBRT2, HALF_PI, TWO_PI, SIXTH_PI;

  H =  3 * (C-B) + A-D;

  FAB = (B-C-C) * ( B * (B+B+C) - C * (A*3+C) )
    + D * ( A * ( A+D - 3*(B+C) ) + B * (6*B-3*C) );
  x = 27*(FAB-H*H*E); /* <- E isolated
  if the curve ABCD is static and you're testing several points E against it
  then H, FAB, G, J are static and caching them may be faster?  
  the x,n and r depends on the value of E though
  be aware the name of the variables and the logic of the code may change
  */

  G =  9 * ( A*(C-D) + B*(D+C-B) - C*C );

  J = ( A + C - B - B ) / H;

  CBRT2 = 1.2599210498948731647672106072782;

  HALF_PI = 1.5707963267948966192313216916397;

  TWO_PI = 6.28318530717958647692528676655;

  SIXTH_PI = 0.5235987755982988730771072305465;

  FG = x*x+4*G*G*G;

  double aX = Math.abs(x);
  y = Math.sqrt(Math.abs(FG));
  if (FG>=0) {
    n = Math.cbrt(Math.abs(x+y));
    if (x+y>=0)r=TWO_PI/3;
    else r = PI;
    /* 
       if (x+y>=0)r=TWO_PI/3;
       else r = PI;
       is equivalent to;
       r=(Math.atan2(0,y+x)+TWO_PI)/3; 
       but should be faster
    */
  } else {
    n = Math.cbrt(aX+y);
    r = (Math.atan2(y,x)+TWO_PI)/3;
    /* 
    if Math.atan2 is slow try this code by
    njuffa @ https://math.stackexchange.com/a/1105038 
    double a, s;
    a=Math.min(aX, y)/Math.max(aX, y); 
    s = a*a;
    r= ((-0.0464964749 * s + 0.15931422) * s - 0.327622764) * s * a + a;
    if (y>aX)r=HALF_PI-r;
    if (x<0)r=PI-r;
    r = (r+TWO_PI)/3;
    */
  }

  multr = CBRT2*(G+G-CBRT2*n*n)/(6*H*n);
  /*
  if Math.sin is slow try fastsin()
  */
  T[0] = Math.sin( -r - HALF_PI  ) * multr + J;
  T[1] = Math.sin(  r + SIXTH_PI ) * multr + J;
  T[2] = Math.sin( -r + SIXTH_PI ) * multr + J;

  return T;
}
