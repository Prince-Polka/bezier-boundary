/*

removed complex class using raw doubles instead, merged helper functions into the main function  
probably more can be done

reduced calculation of F 
  to 14 *,  8 +, and 8 -
from 40 *, 15 +, and 6 -

*/

double[] bezierTime( double A, double B, double C, double D, double E ) {
  double[] T = new double[3];
  double F, G, H, J;
  final double K, cbrt2, sqrt3;

  F = 3*(B-C)+D-A;
  F = 27*((B-C-C)*(B*(B+B+C)-C*(C+A*3))+D*(A*(A+D-3*(B+C))+B*(6*B-3*C))-(F*F*E));
 
  G =  9 * ( A*(C-D) + B*(-B+C+D) - C*C );
 
  H = A - 3*B + 3*C - D;
 
  J = (A - 2*B + C)/H;
 
  K = 4.7622031559045984242551169178169; // 3 * pow(2,2/3)
 
  cbrt2 = 1.2599210498948731647672106072782;
 
  sqrt3 = 1.7320508075688772935274463415059;
 
  double FG, foo, Rootr=0,Rooti=0;
 
  FG = F*F+4*G*G*G;
 
  double s, rot, in;
  s = Math.sqrt(Math.abs(FG));
  if (FG >= 0) Rootr = s;
  else Rooti = s;
 
  Rootr+=F;
 
  rot = Math.cbrt( Math.sqrt(Rootr*Rootr+Rooti*Rooti) );
  in = ( Math.atan2(Rooti, Rootr)+TAU ) / 3;
  Rootr = rot*Math.cos(in);
  Rooti = rot*Math.sin(in); // sincos possible ?
 
  double tr, ti, trti, zr, zi;
  tr=K*H*Rootr;
  ti=K*H*Rooti;
  trti = tr*tr+ti*ti;
  zr=( G*tr)/trti;
  zi=(-G*ti)/trti*sqrt3;
 
  H*=3;
 
  tr=H*Rootr;
  ti=H*Rooti;
  trti = tr*tr+ti*ti;
  foo = (cbrt2*G*tr)/trti;
 
  H*=cbrt2;
 
  double MR, PR, MG, PG; 
  MR = Rootr+Rooti*sqrt3;
  PR = Rootr-Rooti*sqrt3;
  MG = zr+zi;
  PG = zr-zi;
 
  T[0] = + Rootr/H - foo + J;
  T[1] = - MR/(H+H) + PG + J;
  T[2] = - PR/(H+H) + MG + J;
 
  return T;
}
