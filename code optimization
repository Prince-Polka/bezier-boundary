/*

removed complex class using raw doubles instead, merged helper functions into the main function  
probably more can be done

simplified calculation of F 

*/

double[] bezierTime( double A, double B, double C, double D, double E ) {
  double[] T = new double[3];
  double F, G, H, J;
  final double K,U, cbrt2, sqrt3;
 
  H = 3*(C-B) + A-D;
 
  F = 27*((B-C-C)*(B*(B+B+C)-C*(C+A*3))+D*(A*(A+D-3*(B+C))+B*(6*B-3*C))-(H*H*E));
 
  G =  9 * ( A*(C-D) + B*(C-B+D) - C*C );
 
  J = ( A + C - B - B )/H;
 
  K = 4.7622031559045984242551169178169; //2^2/3 *3
  
  U = 1.5874010519681994747517056392723; //2^2/3
 
  cbrt2 = 1.2599210498948731647672106072782;
 
  sqrt3 = 1.7320508075688772935274463415059;
 
  double FG, X=0,Y=0;
 
  FG = F*F+4*G*G*G;
 
  double s, r, n;
  s = Math.sqrt(Math.abs(FG));
  
  if(FG>=0){
    X =F+s;
    r = Math.cbrt(Math.abs(X));
  }
  else {
    X=F;
    Y=s;
    r = Math.cbrt(Math.abs(F)+s);
  }
  
  n = ( Math.atan2(Y, X)+TAU )/3; // TAU = 2*PI
  

  double x,y,z,w;
  
  X = Math.cos(n);
  Y = Math.sin(n)*sqrt3;
 
  /*
  to the right is equivalent expression in sin form
  incase of vector instruction for sine
  */
  
  x = X;          //  sin(n + PI/2 ); 1.5707963267948966192313216916397
  
  y =  0.5*(Y+X); //  sin(n + PI/6 ); 0.5235987755982988730771072305465
  
  z = -0.5*(Y-X); // -sin(n - PI/6); 
  
  w = ( (G+G)/(H*K*r) - r/(3*H*cbrt2) );  

  T[0] = x * ( U*r*r - 2*cbrt2*G ) / ( 6*H*r ) + J;
  T[1] = y * w + J;
  T[2] = z * w + J;
  
  return T;
}
