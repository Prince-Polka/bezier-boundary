/*

removed complex class using raw doubles instead, merged helper functions into the main function  
probably more can be done

simplified calculation of F 

simplified calculation of solutions

added alternatives for sine and atan2

unclear how accurate they are and wheter they be faster or slower

*/

final static double fastsin(double x) {
  /*
  will be way off for x not in range -Pi Pi
  */
  final double x2=x*x;
  return x 
  - (x*=x2)/6 
  + (x*=x2)/120 
  - (x*=x2)/5040 
  + (x*=x2)/362880 
  - (x*=x2)/39916800 
  + (x*=x2)/6227020800D
  - (x*=x2)/1307674368000D
  + (x*=x2)/355687428096000D;
}

double[] bezierTime( double A, double B, double C, double D, double E ) {
  double[] T = new double[3];
  double FAB, G, H, J, FG, x, y, n, r, multn;
  final double CBRT2, HALF_PI, TWO_PI, SIXTH_PI;

  H =  3 * (C-B) + A-D;

  FAB = (B-C-C) * ( B * (B+B+C) - C * (A*3+C) )
    + D * ( A * ( A+D - 3*(B+C) ) + B * (6*B-3*C) );
  x = 27*(FAB-H*H*E); /* <- E isolated
   if the curve ABCD is static and you're testing several points E against it
   then H, FAB, G, J are static and caching them may be faster?  
   the x,n and r depends on the value of E though
   be aware the name of the variables and the logic of the code may change
   */

  G =  9 * ( A*(C-D) + B*(D+C-B) - C*C );

  J = ( A + C - B - B ) / H;

  CBRT2 = 1.2599210498948731647672106072782;

  HALF_PI = 1.5707963267948966192313216916397;

  TWO_PI = 6.28318530717958647692528676655;

  SIXTH_PI = 0.5235987755982988730771072305465;

  FG = x*x+4*G*G*G;

  double aX = Math.abs(x);
  y = Math.sqrt(Math.abs(FG));
  if (FG>=0) {
    /* this case does not need to calculate neither atan2 or sin */
    n = Math.cbrt(Math.abs(x+y));
    multn = CBRT2*(G+G-CBRT2*n*n)/(6*H*n);
    if (x+y>=0) {
      T[0] = 0.5*multn + J;
      T[1] = T[0];
      T[2] = -multn + J;
    } else {
      T[0] = multn + J;
      T[1] = -0.5 * multn + J;
      T[2] = T[1];
    }
  } else {
    /* for now I need atan2 and sin here but hope I can remove them */
    n = Math.cbrt(aX+y);
    multn = CBRT2*(G+G-CBRT2*n*n)/(6*H*n);
    r = (Math.atan2(y, x)+TWO_PI)/3;
    /* 
     if Math.atan2 is slow try this code by
     njuffa @ https://math.stackexchange.com/a/1105038 
     double a, s;
     a=Math.min(aX, y)/Math.max(aX, y); 
     s = a*a;
     r= ((-0.0464964749 * s + 0.15931422) * s - 0.327622764) * s * a + a;
     if (y>aX)r=HALF_PI-r;
     if (x<0)r=PI-r;
     r = (r+TWO_PI)/3;
     */
    
    /*
  if Math.sin is slow try fastsin()
     */
    T[0] = Math.sin( -r - HALF_PI  ) * multn + J;
    T[1] = Math.sin(  r + SIXTH_PI ) * multn + J;
    T[2] = Math.sin( -r + SIXTH_PI ) * multn + J;
  }
  return T;
}
