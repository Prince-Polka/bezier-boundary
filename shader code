// Author: Prince Polka
// Title: BezierTime

#ifdef GL_ES
precision highp float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;
const float
A = 300.,
B=-50.,
C=550.,
D=100.,
H = 3.*(C-B) + A-D,
FAB = (B-C-C)*(B*(B+B+C)-C*(C+A*3.))+D*(A*(A+D-3.*(B+C))+B*(6.*B-3.*C)),
G =  9. * ( A*(C-D) + B*(C-B+D) - C*C ),
J = ( A + C - B - B )/H,
K = 4.7622031559045984242551169178169,
U = 1.5874010519681994747517056392723,
cbrt2 = 1.2599210498948731647672106072782,
sqrt3 = 1.7320508075688772935274463415059,
TAU = 6.283185307179586476925286766559;
const vec3 rots = vec3(
    1.5707963267948966192313216916397,
    0.5235987755982988730771072305465,
    0.5235987755982988730771072305465
);

vec3 bezierTime(float E) {
    float F = 27.*(FAB-(H*H*E));
    float FG = F*F+4.*G*G*G;
    float s, r, n;
    s = sqrt(abs(FG));
    float ispos = float(FG>=0.)*s;
    float isneg = float(FG<0.)*s;
    r = abs(F+ispos)+isneg;
    r = sign(r)*pow(abs(r),1./3.);
    n = (atan(isneg,F+ispos)+TAU )/3.;
    float  mult0, mult12;
    mult0 = (   U*r*r - 2.*cbrt2*G ) / ( 6.*H*r    );
    mult12 = ( - U*r*r * K  + 12.*G ) / ( 6.*H*r * K);
    return sin( rots+vec3(n,n,-n))*vec3(mult0,mult12,mult12)+ J;
}
void main() {
    gl_FragColor = vec4(bezierTime(gl_FragCoord.x),1.0);
}
