float cbrt(float x){
    return sign(x)*pow(abs(x),1./3.);
}

const float A = 300.,B=-50.,C=550.,D=100.;
const float
H = 3.*(C-B) + A-D,
FAB = (B-C-C)*(B*(B+B+C)-C*(C+A*3.))+D*(A*(A+D-3.*(B+C))+B*(6.*B-3.*C)),
G =  9. * ( A*(C-D) + B*(C-B+D) - C*C ),
J = ( A + C - B - B )/H,
K = 4.7622031559045984242551169178169,
U = 1.5874010519681994747517056392723,
cbrt2 = 1.2599210498948731647672106072782,
sqrt3 = 1.7320508075688772935274463415059,
TAU = 6.283185307179586476925286766559;

const vec3 rots = vec3(
    1.5707963267948966192313216916397,
    0.5235987755982988730771072305465,
   -0.5235987755982988730771072305465
);

vec3 bezierTime(float E) {
  float F = 27.*(FAB-(H*H*E));

  float FG = F*F+4.*G*G*G;
    
  float X=0.,Y=0.;
 
  float s, r, n;
  s = sqrt(abs(FG));
    X=F+s*float(FG>0.0);
    Y=  s*float(FG<0.0);

  r = cbrt( sqrt(X*X+Y*Y) ); //r=cbrt(abs(F)+s);
  n = ( atan(Y,X)+TAU )/3.;

  float w = ( (G+G)/(H*K*r) - r/(3.*H*cbrt2) ); 
  
  return sin(n+rots)*vec3(( U*r*r - 2.*cbrt2*G ) / ( 6.*H*r ),w,-w)+J;
    /*
    line above should do fine but saving this incase
    X = cos(n);
    Y = sin(n)*sqrt3;
    return vec3 (
         X * ( U*r*r - 2.*cbrt2*G ) / ( 6.*H*r ),
         0.5*(Y+X),
        -0.5*(Y-X))*vec3(1,w,w)+J;*/
}
